# Dynamic Programming

# Solution -> 보텀업 다이나믹 프로그래밍
"""
점화식 : a_i = min(a_{i-1}, a_{i/2}, a_{i/3}, a_{i/5}) + 1
a_i : 숫자 i가 1이 되기까지 걸리는 연산의 최소 숫자
즉, a_i = (한 번의 연산) + (한 번 연산의 결과로 나올 수 있는 네 개의 숫자들이 1이 되기까지 필요한 연산 숫자들 중 최솟값)

i 번째 element인 d[i] = 구하고자 하는 a_i
d[0] : 0을 1로 만들 수 있는 연산이 없기 때문에, 의미 없는 숫자
d[1] : 1이 1로 될 때까지 필요한 연산의 숫자. d[1] = 0 -> 이미 리스트 초깃값을 0으로 두었기 때문에 따로 계산할 필요 없음
d[i] = d[i-1] + 1는 a_i = a_{i-1} + 1과 같음. 어떤 숫자 i에 대해서도 연산이 가능
"""

x = int(input())  # 정수 X를 입력

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
for i in range(2, x + 1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i - 1] + 1                  # a_i = a_{i-1} + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)  # a_i = min(a_{i-1}+1, a_{i/2}+1)
    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[x])


# 오답 
"""
4 개의 연산이 정확히 구현되지 않음
1이 되는 여러 연산의 조합을 고려한 게 아니라, 그중 한 연산만 따라가 결과가 1이 나오는 잘못된 코드
"""

# x = int(input())

# cnt = 0
# while x != 1:  # x가 1이 되면 중단
#     if x % 5 == 1 or x % 5 == 2:      # x를 5로 나눈 나머지가 1 or 2라면 1을 빼줌
#         x -= 1
#         cnt += 1
#     elif x % 5 == 3 or x % 5 == 4:    # x를 5로 나눈 나머지가 3 or 4라면 3으로 나눠줌
#         if x % 3 == 1 or x % 3 == 2:  # x를 3으로 나눈 나머지가 1 or 2라면 2로 나눠줌
#             x /= 2
#             cnt += 1
#         else:  # x가 3으로 나누어 떨어지는 경우
#             x /= 3
#             cnt += 1
#     else:      # x가 5로 나누어 떨어지는 경우
#         x /= 5
#         cnt += 1

# print(cnt)           